const {
  SpecialOrderRequest,
  User,
  Shop,
  Category,
  Wallet,
  WalletTransaction,
} = require("../models");
const { Op } = require("sequelize");

// Customer creates a special order request
const createSpecialOrderRequest = async (req, res) => {
  try {
    const {
      product_name,
      description,
      category,
      budget,
      quantity,
      delivery_date,
      shipping_address,
      additional_notes,
    } = req.body;

    const userId = req.user.id;

    // Validate required fields
    if (!product_name || !description || !shipping_address) {
      return res.status(400).json({
        message: "T√™n s·∫£n ph·∫©m, m√¥ t·∫£ v√† ƒë·ªãa ch·ªâ giao h√†ng l√† b·∫Øt bu·ªôc",
      });
    }

    // Create special order request
    const specialRequest = await SpecialOrderRequest.create({
      user_id: userId,
      product_name,
      description,
      category,
      budget: budget ? parseFloat(budget) : null,
      quantity: quantity ? parseInt(quantity) : 1,
      delivery_date: delivery_date || null,
      shipping_address,
      additional_notes: additional_notes || null,
      status: "pending",
    });

    res.status(201).json({
      message: "Y√™u c·∫ßu ƒë·∫∑t h√†ng ƒë·∫∑c bi·ªát ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng",
      specialRequest,
    });
  } catch (error) {
    console.error("Error creating special order request:", error);
    res.status(500).json({ message: "L·ªói server" });
  }
};

// Get special order requests (different views for different roles)
const getSpecialOrderRequests = async (req, res) => {
  try {
    console.log("üîç [SpecialOrderController] Fetching special order requests");
    console.log("üë§ [SpecialOrderController] User:", {
      id: req.user.id,
      role: req.user.role,
    });

    const { page = 1, limit = 10, status, category } = req.query;
    console.log("üìä [SpecialOrderController] Query params:", {
      page,
      limit,
      status,
      category,
    });

    const offset = (page - 1) * limit;

    // Build where clause
    const where = {};

    // Role-based filtering
    if (req.user.role === "customer") {
      // Customers can only see their own requests
      where.user_id = req.user.id;
      console.log(
        "üë®‚Äçüíº [SpecialOrderController] Customer role - filtering by user_id:",
        req.user.id
      );
    } else if (req.user.role === "florist") {
      // Florists see either unassigned requests or requests assigned to their shop
      const shop = await Shop.findOne({ where: { florist_id: req.user.id } });
      console.log(
        "üå∏ [SpecialOrderController] Florist role - shop found:",
        shop?.id
      );
      if (!shop) {
        console.log(
          "‚ö™ [SpecialOrderController] Florist without shop - showing unassigned only"
        );
        where.assigned_shop_id = null;
      } else {
        where[Op.or] = [
          { assigned_shop_id: null }, // Unassigned requests
          { assigned_shop_id: shop.id }, // Requests assigned to their shop
        ];
        console.log("üå∏ [SpecialOrderController] Florist where clause:", where);
      }
    } else {
      console.log("üëë [SpecialOrderController] Admin role - no user filtering");
    }
    // Admins can see all requests (no additional filtering)

    // Add status filter if provided
    if (status) {
      where.status = status;
      console.log("üè∑Ô∏è [SpecialOrderController] Added status filter:", status);
    }

    // Add category filter if provided
    if (category) {
      where.category = category;
      console.log(
        "üìÇ [SpecialOrderController] Added category filter:",
        category
      );
    }

    console.log("üîç [SpecialOrderController] Final where clause:", where);

    const { count, rows } = await SpecialOrderRequest.findAndCountAll({
      where,
      include: [
        {
          model: User,
          as: "customer",
          attributes: ["id", "name", "email", "phone"],
        },
        {
          model: Shop,
          as: "assignedShop",
          attributes: ["id", "name"],
          include: [
            {
              model: User,
              as: "florist",
              attributes: ["id", "name"],
            },
          ],
        },
      ],
      limit: parseInt(limit),
      offset: parseInt(offset),
      order: [["created_at", "DESC"]],
    });

    console.log("üìä [SpecialOrderController] Query results:", {
      count,
      rowsLength: rows.length,
      page: parseInt(page),
      pages: Math.ceil(count / limit),
    });

    console.log(
      "üìã [SpecialOrderController] Sample data (first item):",
      rows.length > 0
        ? {
            id: rows[0].id,
            product_name: rows[0].product_name,
            status: rows[0].status,
            budget: rows[0].budget,
            customer: rows[0].customer?.name,
            assignedShop: rows[0].assignedShop?.name,
          }
        : "No items"
    );

    const response = {
      specialRequests: rows,
      total: count,
      page: parseInt(page),
      pages: Math.ceil(count / limit),
    };

    console.log("‚úÖ [SpecialOrderController] Sending response:", {
      specialRequestsCount: rows.length,
      total: count,
      page: parseInt(page),
      pages: Math.ceil(count / limit),
    });

    res.json(response);
  } catch (error) {
    console.error(
      "‚ùå [SpecialOrderController] Error fetching special order requests:",
      error
    );
    console.error("‚ùå [SpecialOrderController] Error stack:", error.stack);
    res.status(500).json({ message: "L·ªói server" });
  }
};

// Get a specific special order request by ID
const getSpecialOrderRequestById = async (req, res) => {
  try {
    const { id } = req.params;

    const specialRequest = await SpecialOrderRequest.findByPk(id, {
      include: [
        {
          model: User,
          as: "customer",
          attributes: ["id", "name", "email", "phone"],
        },
        {
          model: Shop,
          as: "assignedShop",
          attributes: ["id", "name"],
          include: [
            {
              model: User,
              as: "florist",
              attributes: ["id", "name"],
            },
          ],
        },
      ],
    });

    if (!specialRequest) {
      return res
        .status(404)
        .json({ message: "Kh√¥ng t√¨m th·∫•y y√™u c·∫ßu ƒë·∫∑t h√†ng ƒë·∫∑c bi·ªát" });
    }

    // Authorization check
    if (
      req.user.role === "customer" &&
      specialRequest.user_id !== req.user.id
    ) {
      return res.status(403).json({ message: "B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p" });
    }

    if (req.user.role === "florist") {
      const shop = await Shop.findOne({ where: { florist_id: req.user.id } });
      if (
        shop &&
        specialRequest.assigned_shop_id !== null &&
        specialRequest.assigned_shop_id !== shop.id
      ) {
        return res.status(403).json({ message: "B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p" });
      }
    }

    res.json({ specialRequest });
  } catch (error) {
    console.error("Error fetching special order request:", error);
    res.status(500).json({ message: "L·ªói server" });
  }
};

// Update special order request status
const updateSpecialOrderRequestStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status, assigned_shop_id } = req.body;

    if (status) {
      const allowedStatuses = [
        "pending",
        "processing",
        "completed",
        "cancelled",
      ];
      if (!allowedStatuses.includes(status)) {
        return res.status(400).json({ message: "Tr·∫°ng th√°i kh√¥ng h·ª£p l·ªá" });
      }
    }

    // Only admins and florists can update status
    if (req.user.role === "customer") {
      return res
        .status(403)
        .json({ message: "B·∫°n kh√¥ng c√≥ quy·ªÅn c·∫≠p nh·∫≠t tr·∫°ng th√°i" });
    }

    const specialRequest = await SpecialOrderRequest.findByPk(id);
    if (!specialRequest) {
      return res
        .status(404)
        .json({ message: "Kh√¥ng t√¨m th·∫•y y√™u c·∫ßu ƒë·∫∑t h√†ng ƒë·∫∑c bi·ªát" });
    }

    const previousStatus = specialRequest.status;

    // Florists can only update requests assigned to their shop or assign themselves to unassigned requests
    if (req.user.role === "florist") {
      const shop = await Shop.findOne({ where: { florist_id: req.user.id } });
      if (!shop) {
        return res.status(403).json({ message: "B·∫°n kh√¥ng c√≥ c·ª≠a h√†ng" });
      }

      // Allow florist to accept an unassigned request
      if (!specialRequest.assigned_shop_id && assigned_shop_id === shop.id) {
        await specialRequest.update({
          assigned_shop_id: shop.id,
          status: "processing",
        });
        return res.json({
          message: "ƒê√£ nh·∫≠n y√™u c·∫ßu ƒë·∫∑t h√†ng ƒë·∫∑c bi·ªát",
          specialRequest: await SpecialOrderRequest.findByPk(id, {
            include: [
              { model: User, as: "customer", attributes: ["id", "name"] },
              { model: Shop, as: "assignedShop", attributes: ["id", "name"] },
            ],
          }),
        });
      }

      // Only update if request is assigned to their shop
      if (specialRequest.assigned_shop_id !== shop.id) {
        return res
          .status(403)
          .json({ message: "B·∫°n kh√¥ng c√≥ quy·ªÅn c·∫≠p nh·∫≠t y√™u c·∫ßu n√†y" });
      }
    }

    // Update the request
    const updateData = { status };
    if (assigned_shop_id !== undefined) {
      updateData.assigned_shop_id = assigned_shop_id;
    }

    await specialRequest.update(updateData);

    await specialRequest.reload({
      include: [
        { model: User, as: "customer", attributes: ["id", "name"] },
        {
          model: Shop,
          as: "assignedShop",
          attributes: ["id", "name", "florist_id"],
          include: [{ model: User, as: "florist", attributes: ["id", "name"] }],
        },
      ],
    });

    if (status === "completed" && previousStatus !== "completed") {
      const assignedShopId =
        specialRequest.assigned_shop_id ?? specialRequest.assignedShop?.id;
      const floristId = specialRequest.assignedShop?.florist_id;
      const payoutAmount = Number(specialRequest.budget || 0);

      if (assignedShopId && floristId && payoutAmount > 0) {
        const [wallet] = await Wallet.findOrCreate({
          where: { user_id: floristId },
          defaults: { balance: 0.0 },
        });

        const referenceId = `special_request_${specialRequest.id}_payout`;
        const existingTransaction = await WalletTransaction.findOne({
          where: { wallet_id: wallet.id, reference_id: referenceId },
        });

        if (!existingTransaction) {
          const currentBalance = Number(wallet.balance);
          const newBalance = currentBalance + payoutAmount;

          await wallet.update({ balance: newBalance });
          await WalletTransaction.create({
            wallet_id: wallet.id,
            type: "deposit",
            amount: payoutAmount,
            description: `Thu nh·∫≠p y√™u c·∫ßu ƒë·∫∑c bi·ªát #${specialRequest.id}`,
            balance_after: newBalance,
            reference_id: referenceId,
            metadata: {
              special_order_request_id: specialRequest.id,
              assigned_shop_id: assignedShopId,
              budget: payoutAmount,
            },
          });
        }
      }
    }

    const updatedRequest = specialRequest;

    res.json({
      message: "C·∫≠p nh·∫≠t tr·∫°ng th√°i th√†nh c√¥ng",
      specialRequest: updatedRequest,
    });
  } catch (error) {
    console.error("Error updating special order request status:", error);
    res.status(500).json({ message: "L·ªói server" });
  }
};

// Customer updates their own special order request (only if pending)
const updateSpecialOrderRequest = async (req, res) => {
  try {
    const { id } = req.params;
    const {
      product_name,
      description,
      category,
      budget,
      quantity,
      delivery_date,
      shipping_address,
      additional_notes,
    } = req.body;

    const specialRequest = await SpecialOrderRequest.findByPk(id);
    if (!specialRequest) {
      return res
        .status(404)
        .json({ message: "Kh√¥ng t√¨m th·∫•y y√™u c·∫ßu ƒë·∫∑t h√†ng ƒë·∫∑c bi·ªát" });
    }

    // Only customer who created the request can update it
    if (specialRequest.user_id !== req.user.id) {
      return res.status(403).json({ message: "B·∫°n kh√¥ng c√≥ quy·ªÅn c·∫≠p nh·∫≠t" });
    }

    // Only allow updates if status is pending
    if (specialRequest.status !== "pending") {
      return res.status(400).json({
        message: "Ch·ªâ c√≥ th·ªÉ c·∫≠p nh·∫≠t y√™u c·∫ßu ·ªü tr·∫°ng th√°i 'pending'",
      });
    }

    // Update the request
    const updateData = {};
    if (product_name) updateData.product_name = product_name;
    if (description) updateData.description = description;
    if (category !== undefined) updateData.category = category;
    if (budget !== undefined)
      updateData.budget = budget ? parseFloat(budget) : null;
    if (quantity) updateData.quantity = parseInt(quantity);
    if (delivery_date !== undefined) updateData.delivery_date = delivery_date;
    if (shipping_address) updateData.shipping_address = shipping_address;
    if (additional_notes !== undefined)
      updateData.additional_notes = additional_notes;

    await specialRequest.update(updateData);

    const updatedRequest = await SpecialOrderRequest.findByPk(id, {
      include: [
        { model: User, as: "customer", attributes: ["id", "name"] },
        { model: Shop, as: "assignedShop", attributes: ["id", "name"] },
      ],
    });

    res.json({
      message: "C·∫≠p nh·∫≠t y√™u c·∫ßu th√†nh c√¥ng",
      specialRequest: updatedRequest,
    });
  } catch (error) {
    console.error("Error updating special order request:", error);
    res.status(500).json({ message: "L·ªói server" });
  }
};

// Delete/Cancel special order request
const deleteSpecialOrderRequest = async (req, res) => {
  try {
    const { id } = req.params;

    const specialRequest = await SpecialOrderRequest.findByPk(id);
    if (!specialRequest) {
      return res
        .status(404)
        .json({ message: "Kh√¥ng t√¨m th·∫•y y√™u c·∫ßu ƒë·∫∑t h√†ng ƒë·∫∑c bi·ªát" });
    }

    // Only customer who created it or admin can delete
    if (
      req.user.role === "customer" &&
      specialRequest.user_id !== req.user.id
    ) {
      return res.status(403).json({ message: "B·∫°n kh√¥ng c√≥ quy·ªÅn x√≥a" });
    }

    if (req.user.role === "florist") {
      return res.status(403).json({ message: "Florist kh√¥ng th·ªÉ x√≥a y√™u c·∫ßu" });
    }

    // Only allow deletion if status is pending
    if (specialRequest.status !== "pending") {
      return res.status(400).json({
        message: "Ch·ªâ c√≥ th·ªÉ h·ªßy y√™u c·∫ßu ·ªü tr·∫°ng th√°i 'pending'",
      });
    }

    await specialRequest.update({ status: "cancelled" });

    res.json({
      message: "ƒê√£ h·ªßy y√™u c·∫ßu ƒë·∫∑t h√†ng ƒë·∫∑c bi·ªát",
      specialRequest,
    });
  } catch (error) {
    console.error("Error deleting special order request:", error);
    res.status(500).json({ message: "L·ªói server" });
  }
};

// Get available categories for special orders
const getAvailableCategories = async (req, res) => {
  try {
    const categories = await Category.findAll({
      where: { is_active: 1 },
      attributes: ["id", "name", "description"],
      order: [["name", "ASC"]],
    });

    res.json({ categories });
  } catch (error) {
    console.error("Error fetching categories:", error);
    res.status(500).json({ message: "L·ªói server" });
  }
};

module.exports = {
  createSpecialOrderRequest,
  getSpecialOrderRequests,
  getSpecialOrderRequestById,
  updateSpecialOrderRequestStatus,
  updateSpecialOrderRequest,
  deleteSpecialOrderRequest,
  getAvailableCategories,
};
